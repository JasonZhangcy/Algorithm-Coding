/**
*时间复杂度：O(n)
*思想：用两个指针，一快一慢，慢指针指向目前不重复的元素，快指针找下一个不重复的元素，然后与slow的下一个位置交换（实际不用交换，直接复制过去就行）
*/
public class Solution {
    public int removeDuplicates(int[] nums) {
        if(nums.length == 0) return 0;
        int fast = 1, slow = 0;
        while(fast < nums.length){
            if(nums[fast] != nums[slow])
                nums[++slow] = nums[fast];
            fast++;
        }
        //因为是返回数组长度，所以要+1
        return slow+1;
    }
}

/**
 *如果题目要求保留所有元素则必须交换，做法如下
 */
class Solution {
    public int removeDuplicates(int[] nums) {
        if (nums.length == 0 || nums == null) return 0;
        int p = 0, cur = 0;
        while (p < nums.length) {
            //当前元素与后一个元素对比，而不是与前一个元素对比
            //这样做的原因是，交换了元素之后，p所在的元素之前的元素是乱的，无法比较
            //这样做可以保证每次开始循环时，p所指的元素是第一个不同于前面的元素
            while (p < nums.length - 1 && nums[p] == nums[p + 1])
                p++;
            int tmp = nums[cur];
            nums[cur++] = nums[p];
            nums[p++] = tmp;
        }
        return cur;
    }
}
